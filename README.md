# intelligent-placer
Требуется написать Intelligent Placer, который по поданной фотографии с несколькими предметами на светлой горизонтальной поверхности с многоугольником на белом листе А4 определяет, можно ли поместить эти предметы внутрь многоугольника.
Более точно, Intelligent Placer должен решить, существует ли способ разместить эти предметы в многоугольнике так, чтобы ни один из предметов не выходил за границы многоугольника и к тому же, ни один из этих предметов не накрывал бы собой другие.
В ходе описанного размещения предметов мы не должны использовать области внутри них самих, то есть предметы рассматриваюся как единое целое, без дырок.
# Постановка задачи
### Общие
- На вход Intelligent Placer поступает путь до фотографии (с предметами и прямоугольником)
- Программа отвечает True если предметы помещаются в многоугольник, False иначе.
- Ответ выводится в стандартный поток вывода
### Многоугольник
- Многоугольник должен быть замкнутым и выпуклым. В данном случае, под многоугольником подразумевается лишь замкнутая ломаная, а не вся часть плоскости, ею ограниченная.
- Границы многоугольника должны быть четко видны и нарисованы темным маркером на белом листе бумаги. 
- Толщина линий ломанной не должна быть меньше *1 мм*

### Содержание фотографий
- Предметы должны располагаться вне многоугольника, так, что они не должны пересекаться ни с друг с другом, ни с многоугольником
- 
- Требование к поверхности:
    1. плоская
    2. светлая
    3. горизонтальная
- Объекты могут быть только из заранее определенного множества (определенного в папке *pictures*)
- Один предмет не может присутствовать на фото несколько раз

### Фотометрические
- фотографии должны быть в формате *\*.jpg*
- угол между направлением камеры и перпендикуляром к поверхности должен быть не более *10&deg;*
- расстояние между камерой и поверхностью должно быть таким, чтобы на получившейся фотографии были легко отличимы предметы и видна была граница. Для этого рекомендуется поддерживать данное расстояние не более *0.5 м*
- фотография должны быть снята камерой с штатным объективом либо объективом с фокусным расстоянием, слегка превышающим нормальное. Иными словами, на полученном изображении должна быть обеспечена наиболее естественная перспектива
- на изображении не должно быть длинных теней
- Освещенность должна быть максимально естественная для человеческого глаза.
- фотография резкая, не смазанная
- отсутствие существенного засвета

# План
0. Подготавливаем изображение: переводим его в ч/б.
2. Применим бинаризацию Оцу
3. Среди контуров, таких, что они внутри белые (смотрим по гистограмме), находим максимум по площади. Это и будет многоугольник.
3. Находим предметы
    * используем бинаризацию
    * используем морфологию закрытия/открытия
    * многоугольник убираем
    * находим компоненты связности
4. Для каждой такой компоненты связности находим ее ограничивающую рамку
5. Далее задача сводится к задаче упаковки прямоугольников в многоугольник. 
    * Будем использовать жадный алгоритм. Задав шаг перебора, переберем всевозможные положения и повороты маски предмета и многоугольника. Для того, чтобы понять, укладывается ли предмет в многоугольник или нет, будем применять *логическое И* для маски предмета и части многоугольника. Если в результате применения этой операции сумма по всем пикселям результата логического И окажется равна нулю, это означает, что предмет поместился. Если таким образом поместились все предметы, то вернем True. Если на каком-то этапе предмет не поместился, сразу возращаем False.
6. Для оценки работы алгоритма можем использовать метрики. FP, TP, FN, TN, Accuracy, Recall, Precision



# Оценка качества
| Метрика | Значение |
| ----------- | ----------- |
| True Positive|9|
| True Negative| 7 |
| False Positive | 0|
|False Negative|  1|
|Accuracy| 0.9411|
|Recall|0.9| 
|Precision| 1.0|

* Из метрик видим, что алгоритм достаточно хорошо дает правильные ответы(False) для тех предметов, которые нельзя поместить в многоугольники. Однако, из-за жадности алгоритма мы можем пропустить случаи, когда предметы все-таки можно поместить в многоугольник.
* Эта особенность алгоритма хороша видна на тестах 16 и 17, там те же предметы, тот же многоугольник, только по-разному повернут. На одном тесте алгоритм выдает True, на другом False. Рассмотрим работу алгоритма подробнее, чтобы понять, в чем тут дело. Алгоритм в обоих случаях сначала прикладывает первую маску - монету - в обоих случаях она помещается. Дальше он пытается приложить зарядку, и тут, в зависимости от поворота многоугольника, она может поместиться, а может нет. Если бы это был полный перебор, она бы в любом случае поместилась - мы бы продолжили поиск, начав укладку теперь с зарядки. Но жадный алгоритм, как только не может разместить предмет, сразу выдает False, завершая свою работу.
* Вместо жадного алгоритма можно использовать полный перебор, однако, он сильно увеличит время работы программы. Поэтому, как идею улучшения, можно рассмотреть различные эвристики. Например, идею размещать сначала предметы с углом "подобным" (похожим по какой-то метрике) какому-то углу многоугольника. Мы легко можем аппроксимировать каждый предмет многоугольником встроенными средствами, а затем найти его внутренние углы (через скалярного произведение). Рассмотрим это на примере 16 и 17 теста: в многоугольнике есть угол, близкий к 90&deg;, подобный угол имеется у зарядки, но не у монеты (там все углы будут близки 0&deg;). Размещая зарядку к этому углу, мы всегда сможем затем поместить монету. Разумеется, это всего лишь эвристика, и она не гарантирует точное/оптимальное решение, но в каких-то случаях она дает верный результат


# Данные
- [Изображения объектов](pictures)
- [Тесты](tests)
- [Разметка тестов](tests/tests.csv)
- [Описание тестов](tests/description.txt)
